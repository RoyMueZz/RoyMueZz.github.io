<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2FRoyMueZz.github.io%2Fgit.html</url>
    <content type="text"><![CDATA[分支分支的命令 查看本地分支 1git branch 查看远程分支 1git branch -r 查看全部分支(包含本地和远程) 1git branch -a 创建分支 1git branch (名字) 切换到新创建的分支 1git checkout (名字) 将新分支push到github 1git push origin (名字) 删除本地分支 1git branch -D (名字) 删除远程分支 1git push origin --delete (名字) 分支合并当在某个分支开发完功能之后测试无误之后，想合并到主分支上 本地切换回主分支 1git checkout (主分支的名字) 合并分支 1git merge origin/(其他分支的名字) 推送远程 1git push]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2FRoyMueZz.github.io%2Fcss.html</url>
    <content type="text"><![CDATA[padding 占位图片没有加载完成之前的图片的盒子是没有高度的，这样对整体网页会有抖动，影响体验 123&lt;div class="wrapper"&gt; &lt;img src="..." class="wrapper__img" /&gt;&lt;/div&gt; 123456789.wrapper &#123; overflow: hidden; width: 100%; height: 0; padding-bottom: (图片的高度 / 图片的宽度);&#125;.wrapper__img &#123; width: 100%;&#125; min-width:0 文字超出隐藏有时会出现 white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 加了这些样式,可是文字还是没有省略。只要在父级元素上加上 min-width: 0 12345&lt;div class="item-info"&gt; &lt;p class="item-title"&gt;大连圣亚海洋世界&lt;/p&gt; &lt;p class="item-desc"&gt;浪漫大连首站，浪漫的海洋主题乐园&lt;/p&gt; &lt;button class="item-btn"&gt;查看更多&lt;/button&gt;&lt;/div&gt; 12345678910111213.item-info &#123; ... min-width: 0;&#125;.item-title &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.item-desc &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2FRoyMueZz.github.io%2Fwebpack.html</url>
    <content type="text"><![CDATA[webpack 是一个现代 JavaScript 应用程序的静态模块打包工具：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并生成一个或多个 bundle，将其打包为合适的格式以供浏览器使用。 webpack 的配置文件在项目根目录下创建 webpack.config.js 文件，这是 webpack 默认配置文件 123456789101112131415const path = require('path')module.exports = &#123; //默认是production，打包的文件默认被压缩。开发时可以设置为development，不被压缩 mode: 'production', //打包项目的入口文件 entry: './index.js', //打包项目的输出文件 output: &#123; //自定义打包输出文件名 filename: 'bundle.js', //输出文件的绝对路径 path: path.resolve(__dirname, 'bundle'), &#125;,&#125; Loaderfile-loader支持加载图片文件: file-loader 解决 CSS 等文件中的引入图片路径问题 1npm install file-loader -D 12345678910111213141516171819202122// webpack.config.js 配置loadermodule.exports = &#123; //配置模块,主要用来配置不同文件的加载器 module: &#123; //配置模块规则 rules: [ &#123; test: /\.(png|jpg|gif)$/, //正则匹配要使用相应loader的文件 test: /\.(eot|ttf|svg|woff)$/, // 引入字体图标的loader use: [ &#123; loader: 'file-loader', //要用到的loader options: &#123; //palceholder占位符 name: '[name].[ext]', //打包后的图片名字，后缀和打包的之前的图片一样 outputPath: 'images/', //图片打包后的地址 &#125;, &#125;, ], &#125;, ], &#125;,&#125; url-loader将小图片转换成 base64 格式: url-loader 当图片小于 limit 的时候会把图片 BASE64 编码，大于 limit 参数的时候还是使用 file-loader 进行拷贝(file-loader 能做的 url-loader 也能做) 1npm install url-loader -D 1234567891011121314151617181920// webpack.config.js 配置loadermodule.exports = &#123; module: &#123; rules: [ &#123; test: /\.(png|jpg|gif|bmp/)$/i, use: [ &#123; loader: 'url-loader', options: &#123; name:'[name].[ext]', outputPath: 'images/', limit: 8192 //小于8192b,就可以转化成base64格式。大于就会打包成文件格式 &#125; &#125; ] &#125; ] &#125;&#125; css-loader style-loader支持加载样式 CSS 文件: css-loader style-loader 1npm install css-loader style-loader -D 1234567891011// webpack.config.js 配置loadermodule.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, //匹配以css为后缀的文件 use: ['style-loader', 'css-loader'], //loader的执行顺序是从右向左，从下到上。css-loader：分析几个css文件之间的关系，最终合并为一个css。style-loader:在得到css生成的内容时，把其挂载到html的head里，成为内联样式。 &#125;, ], &#125;,&#125; sass-loader node-sass支持加载样式 SASS 文件: sass-loader node-sass 1npm install sass-loader node-sass -D 1234567891011121314// webpack.config.js 配置loadermodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\.scss$/, use: [ "style-loader", // 将 JS 字符串生成为 style 节点 "css-loader", // 将 CSS 转化成 CommonJS 模块 "sass-loader" // 将 Sass 编译成 CSS，默认使用 Node Sass ] &#125;] &#125;&#125;; postcss-loader autoprefixer为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz 这些前缀 Trident 内核：主要代表为 IE 浏览器, 前缀为-ms Gecko 内核：主要代表为 Firefox, 前缀为-moz Presto 内核：主要代表为 Opera, 前缀为-o Webkit 内核：产要代表为 Chrome 和 Safari, 前缀为-webkit 为 css 样式属性加不同浏览器的前缀: postcss-loader autoprefixer 1npm i postcss-loader autoprefixer -D 1234// 在项目跟目录下创建 postcss.config.jsmodule.exports = &#123; plugins: [require('autoprefixer')],&#125; 12345678910111213141516// webpack.config.js 配置loadermodule.exports = &#123; ... module: &#123; rules: [&#123; test: /\.scss$/, use: [ "style-loader", // 将 JS 字符串生成为 style 节点 "css-loader", // 将 CSS 转化成 CommonJS 模块 'postcss-loader',//注意postcss-loader放置位置，应放在css-loader之后，sass|less|stylus-loader之前。 "sass-loader" // 将 Sass 编译成 CSS，默认使用 Node Sass ] &#125;] &#125;&#125;; 12345678910111213141516171819202122// 给loader加一些配置项：module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.scss$/, use: [ "style-loader", &#123; loader: "css-loader", options:&#123; importLoaders:2 ,//如果sass文件里还引入了另外一个sass文件，另一个文件还会从sass-loader向上解析。如果不加，就直接从css-loader开始解析// 0 =&gt; no loaders (default); 1 =&gt; postcss-loader; 2 =&gt; postcss-loader, sass-loader modules: true //开启css的模块打包。css样式不会和其他模块发生耦合和冲突 &#125; &#125;, 'postcss-loader', "sass-loader", ] &#125;] &#125;&#125;; plugin可以在webpack运行到某个时刻的时候，帮你做一些事情(类似于生命周期函数) pHtmlWebpackPluginpHtmlWebpackPlugin: 会在打包结束后，自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中 1npm i html-webpack-plugin -D 1234567891011121314151617// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin')const path = require('path')module.exports = &#123; entry: 'index.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'index_bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; // 默认生成的index.html中没有元素，假如想生成文件的同时在里面创建一个id为root的div，可以在项目的文件夹下(比如src)创建index.html模板，以index.html为模板，把打包生成的js自动引入到这个html文件中 template: 'src/index.html', &#125;), ],&#125; CleanWebpackPluginCleanWebpackPlugin: 自动清除上一次打包的dist文件 1npm i clean-webpack-plugin -D 12345678910111213141516171819// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const path = require('path');module.exports = &#123; entry: 'index.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'index_bundle.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' //在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中 &#125;), new CleanWebpackPlugin(['dist']), // 在打包之前，可以删除dist文件夹下的所有内容 ]&#125;; Entry与Output的基础配置Entry与Output的基础配置: 在打包多入口文件时的配置 1234567891011121314151617181920212223// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const path = require('path');module.exports = &#123; entry: &#123; main: './src/index.js', sub: './src/index.js' &#125;, output: &#123; publicPath: 'http://cdn.com.cn', //将注入到html中的js文件前面加上地址 path: path.resolve(__dirname, 'dist'), filename: '[name].js' // 通过占位符输出2个文件 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' //在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中 &#125;), new CleanWebpackPlugin(['dist']), // 在打包之前，可以删除dist文件夹下的所有内容 ]&#125;; SourceMap 的配置SourceMap: 打包编译后的文件和源文件的映射关系，用于开发者调试用 devtool 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// webpack.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', //devtool:'none', 在开发者模式下，默认开启sourcemap,将其关闭 //devtool:'source-map' 开启映射打包会变慢 //devtool:'inline-source-map' 不单独生成.map文件，会将生成的映射文件以base64的形式插入到打包后的js文件的底部 //devtool:'cheap-inline-source-map' 代码出错提示不用精确显示第几行的第几个字符出错，只显示第几行出错，会提高一些性能 //devtool:'cheap-module-inline-source-map' 不仅管自己的业务代码出错，也管第三方模块和loader的一些报错 //devtool:'eval' 执行效率最快，性能最好，但是针对比较复杂的代码的情况下，提示内容不全面 //devtool: 'cheap-module-eval-source-map', 在开发环境推荐使用，提示比较全，打包速度比较快 //devtool: 'cheap-module-source-map', 在生产环境中推荐使用，提示效果会好一些 entry: &#123; main: './src/index.js' &#125;, module: &#123; rules: [&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 10240 &#125; &#125; &#125;, &#123; test: /\.(eot|ttf|svg)$/, use: &#123; loader: 'file-loader' &#125; &#125;, &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2 &#125; &#125;, 'postcss-loader', 'sass-loader', ] &#125;] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(['dist'])], output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 使用 WebpackDevServer 提升开发效率WebpackDevServer: 解决每次在src里编写完代码都需要手动重新运行 npm run dev 123456789101112&#123; "name": "haiyang", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "bundle": "webpack", "watch": "webpack --watch",// 加--watch自动监听代码的变化 "start": "webpack-dev-server",//配置热更新 &#125;, &#125; 1npm i webpack-dev-server –D contentBase :配置开发服务运行时的文件根目录 open :自动打开浏览器 host：开发服务器监听的主机地址 compress :开发服务器是否启动gzip等压缩 port：开发服务器监听的端口 12345678910111213141516171819202122232425262728// webpack.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', entry: &#123; main: './src/index.js' &#125;,+ devServer: &#123; contentBase: './dist', open: true, port: 8080, proxy: &#123;//配置跨域，访问的域名会被代理到本地的3000端口 '/api': 'http://localhost:3000' &#125; &#125;, module: &#123; rules: [] &#125;, plugins: [], output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 模块热替换(hot module replacement)12345678910// package.json&#123; "name": "haiyang", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "start": "webpack-dev-server" //将文件打包到内存中，有助于开发 &#125;,&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// webpack.config.jsconst path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', entry: &#123; main: './src/index.js' &#125;, devServer: &#123; contentBase: './dist', open: true, port: 8080, hot: true,//开启热更新 hotOnly: true//尽管html功能没有实现，也不让浏览器刷新 &#125;, module: &#123; rules: [&#123; test: /\.(jpg|png|gif)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]_[hash].[ext]', outputPath: 'images/', limit: 10240 &#125; &#125; &#125;, &#123; test: /\.(eot|ttf|svg)$/, use: &#123; loader: 'file-loader' &#125; &#125;, &#123; test: /\.scss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 2 &#125; &#125;, 'postcss-loader', 'sass-loader', ] &#125;, &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader', 'postcss-loader' ] &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'src/index.html' &#125;), new CleanWebpackPlugin(['dist']), new webpack.HotModuleReplacementPlugin() //使用模块热更新插件 ], output: &#123; filename: '[name].js', path: path.resolve(__dirname, 'dist') &#125;&#125; 1234567// index.js//如果模块启用了HMR，就可以用 module.hot.accept(),监听模块的更新。if (module.hot) &#123; module.hot.accept('./library.js', function() &#123; // 使用更新过的 library 模块执行某些操作... &#125;)&#125; 注意点 引入css,用框架Vue，React 时，不需要写 module.hot.accept()，因为在使用css-loader，vue-loader，babel-preset时，就已经配置好了HMR，不需要自己写 使用 Babel 处理 ES6/7 语法 转义为ES5BABEL官网 123npm i babel-loader @babel/core @babel/preset-env -D//生产依赖，兼容低版本浏览器npm install --save @babel/polyfill 123456789101112131415161718192021// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/,//不需要对第三方模块进行转换，耗费性能 loader: "babel-loader" , options:&#123; "presets": [["@babel/preset-env",&#123; targets: &#123;//这个项目运行在大于什么版本的浏览器上，已经支持es6的语法的高版本浏览器就不需要转义成es5了 edge: "17", firefox: "60", chrome: "67", safari: "11.1", &#125;, useBuiltIns:'usage' //按需添加polyfill,把用到的代码都转成低版本浏览器兼容的 &#125;]] &#125; &#125; ]&#125; 12//在业务代码运行之前最顶部导入import "@babel/polyfill"; 注意点 在开发类库，第三方模块或组件库时不能用 @babel/polyfill 这种方案，因为会把声明的变量变成全局变量，会污染全局环境 解决的方法 123npm install --save-dev @babel/plugin-transform-runtimenpm install --save @babel/runtimenpm install --save @babel/runtime-corejs2 123456789101112131415161718// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/,//不需要对第三方模块进行转换，耗费性能 loader: "babel-loader" , options:&#123; "plugins": [["@babel/plugin-transform-runtime",&#123; "corejs": 2, "helpers": true, "regenerator": true, "useESModules": false &#125;]] &#125; &#125; ]&#125; 由于babel需要配置的内容非常多，我们需要在项目根目录下创建一个 .babelrc 文件。就不需要在 webpack.config.js 中写 babel 的配置了。 12345678 &#123; "plugins": [["@babel/plugin-transform-runtime",&#123; "corejs": 2, "helpers": true, "regenerator": true, "useESModules": false &#125;]]&#125; 配置 React 代码的打包 12npm i react react-dom --savenpm install --save-dev @babel/preset-react 1234567891011121314151617 // .babelrc &#123; "presets": [ ["@babel/preset-env",&#123; targets: &#123; edge: "17", firefox: "60", chrome: "67", safari: "11.1", &#125;, useBuiltIns:'usage' &#125; ], "@babel/preset-react" ] &#125;//执行顺序：从下往上，从右向左的顺序]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[settings Sync]]></title>
    <url>%2FRoyMueZz.github.io%2Fsettings-Sync.html</url>
    <content type="text"><![CDATA[如果要在不同的电脑上使用 vscode 配置是件比较麻烦的事情，使用 Settings Sync 将 vscode 配置备份起来，当需要在其他电脑使用 vscode 时只需下载备份的配置就可以了。 使用 Settings Sync 的备份配置的步骤 安装 Settings Sync 插件 来到 github，点击右上角的头像依次选择 Settings &gt;&gt; Developer settings &gt;&gt; Personal access tokens &gt;&gt; Generate new token 在 Note 输入框中填入自己 token 名，滚动页面到 gist 在复选框打上勾 复制下面一串 打开 vscode 找到 settings sync界面 点击 复制刚刚生成的 token 码到下图，左下角出现的勾选说明保存完毕，通过快捷键 Upload Key : Shift + Alt + U 就可以上传到 gist 上 在新电脑上下载安装 Settings Sync 插件之后，到 gist 上复制下面这一串到 settings sync界面 的 gist ID 的输入框中,通过快捷键 Download Key : Shift + Alt + D 就可以配置当前的 vscode 假如下次再上传配置时候,插件可能会报错 令牌无效或过期 那就需要到 github 上获取 token 的地方重新点击 Regenerate token 的来重新获取的 token 回到 vscode 按键盘shift + ctrl + p 输入 sync: 依次点击 sync高级选项 &gt;&gt; sync打开设置 然后把刚刚复制的token输入进去即可，重新执行 Shift + Alt + U 遇到的问题 gist.github.com 被墙无法访问解决办法: windows下 打开C:\Windows\System32\drivers\etc\hosts文件,编辑器打开，在最后行添加 `192.30.253.118 gist.github.com` 保存。]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vuecli3.0脚手架项目工程的搭建]]></title>
    <url>%2FRoyMueZz.github.io%2F%E5%9F%BA%E4%BA%8Evuecli3-0%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[文件目录展示 api123// book.jsimport _axios from "./index";export const book = params =&gt; _axios("get", "/book/ebook", params); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// index.jsimport axios from "axios"; // 创建axios的一个实例var instance = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_URL, // 环境变量 timeout: 6000&#125;);// 一、请求拦截器instance.interceptors.request.use( function(config) &#123; return config; &#125;, function(error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 二、响应拦截器instance.interceptors.response.use( function(response) &#123; return response.data; &#125;, function(error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;);/** * 使用es6的export default导出了一个函数，导出的函数代替axios去帮我们请求数据， * 函数的参数及返回值如下： * @param &#123;String&#125; method 请求的方法：get、post、delete、put * @param &#123;String&#125; url 请求的url: * @param &#123;Object&#125; data 请求的参数 * @returns &#123;Promise&#125; 返回一个promise对象，其实就相当于axios请求数据的返回值 */export default function(method, url, data = null) &#123; method = method.toLowerCase(); if (method == "post") &#123; return instance.post(url, data); &#125; else if (method == "get") &#123; return instance.get(url, &#123; params: data &#125;); &#125; else if (method == "delete") &#123; return instance.delete(url, &#123; params: data &#125;); &#125; else if (method == "put") &#123; return instance.put(url, data); &#125; else &#123; console.error("未知的method" + method); return false; &#125;&#125; 12345678910111213141516171819202122&lt;!-- 使用 --&gt;&lt;script&gt;import &#123; book &#125; from '@/api/book'export default &#123; name: 'app', mounted() &#123; this.books() &#125;, methods: &#123; async books() &#123; //book()执行完, //book_info let book_info = await book() console.log(book_info); //2.2假设登录成功,返回的数据应该是 //book_info=&#123;code:200,msg:'success',data:[]&#125; // 等右边有返回值时，才会继续执行代码 &#125; &#125;&#125;&lt;/script&gt; components global/fa-button 123// index.jsimport faButton from "./index.vue";export default faButton; 123456789101112&lt;!-- index.vue --&gt;&lt;template&gt; &lt;div&gt;test component&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'faButton' // 全局注册的需要定义name值，作为组件的名字&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt;&lt;/style&gt; index.js : 自动加载 global 目录下的 .js 结尾的文件, 来实现自动注册组件目的 12345678910111213// index.jsimport Vue from 'vue'// 自动加载 global 目录下的 .js 结尾的文件const componentsContext = require.context('./global', true, /\.js$/)componentsContext.keys().forEach(component =&gt; &#123; const componentConfig = componentsContext(component) /** * 兼容 import export 和 require module.export 两种规范 */ const ctrl = componentConfig.default || componentConfig Vue.component(ctrl.name, ctrl) 12// main.jsimport '@/components' // 全局组件自动注册 123456&lt;!-- 使用组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;fa-button&gt;&lt;/fa-button&gt; &lt;/div&gt;&lt;/template&gt; router123456789101112// Home/index.jsexport default [ &#123; path:'/', redirect:'/home' &#125;, &#123; path: '/home', name: 'home', component: () =&gt; import(/* webpackChunkName: "index" */ '@/views/Home') &#125;] 12345678910111213141516171819202122232425// index.jsimport Vue from "vue";import Router from "vue-router";Vue.use(Router);let routes = [];// 自动解析 ./ 目录下的 index.js 文件 自动引入该文件中const routerContext = require.context("./", true, /index\.js$/);routerContext.keys().forEach(route =&gt; &#123; // 如果是根目录的 index.js 不处理 if(route.startsWith('./index'))&#123; return &#125; const routerModule = routerContext(route) /** * 兼容 import export 和 require module.export 两种规范 */ routes = [...routes,...(routerModule.default || routerModule)]&#125;)export default new Router(&#123; routes&#125;); store 123456789101112131415161718192021// modules/book.jsconst book = &#123; state: &#123; test: 1 &#125;, actions: &#123; setTest: (&#123; commit, state &#125;, newTest) =&gt; &#123; return commit("SET_TEST", newTest); &#125; &#125;, mutations: &#123; 'SET_TEST': (state, newTest) =&gt; &#123; state.test = newTest; &#125; &#125;, getters: &#123; book: state =&gt; state.test &#125;&#125;;export default book 12345678910111213// index.jsimport Vue from "vue";import Vuex from "vuex";import book from "./modules/book"Vue.use(Vuex);export default new Vuex.Store(&#123; modules:&#123; book &#125;&#125;) 1234567891011121314151617181920212223&lt;!-- 使用 --&gt;&lt;script&gt;// 这样会写很多重复代码而且不方便维护，后面使用mixin的方法统一管理import &#123; mapGetters &#125; from 'vuex'import &#123; mapActions &#125; from 'vuex'// import &#123; ebookMixin &#125; from '@/utils/mixin' export default &#123; name: 'app', // mixins: [ebookMixin], // mixin以当前代码进行混合，减少重复代码 computed: &#123; ...mapGetters(['book']) &#125;, created() &#123; // 提交参数10之后,返回的是promise对象, 来获取 book 的值 this.setTest(10).then(() =&gt; &#123; console.log(this.book); // 获取vuex中book的值 &#125;) &#125;, methods: &#123; ...mapActions(['setTest']) // 这样写就可以简化提交操作，这种提交vuex数据需要在methods中才能生效 &#125;&#125;&lt;/script&gt; utils12345678910//book.js 存放某个模块下的静态变量export const FONT_SIZE_LIST = [ &#123; fontSize: 12 &#125;, &#123; fontSize: 14 &#125;, &#123; fontSize: 16 &#125;, &#123; fontSize: 18 &#125;, &#123; fontSize: 20 &#125;, &#123; fontSize: 22 &#125;, &#123; fontSize: 24 &#125;]; npm install web-storage-cache -S 1234567891011121314151617181920// localStorage.js 引入第三方库(进行超时处理，序列化)import Storage from "web-storage-cache";const localStorage = new Storage();export function setLocalStorage(key, value) &#123; return localStorage.set(key, value);&#125;export function getLocalStorage(key) &#123; return localStorage.get(key);&#125;export function removeLocalStorage(key) &#123; return localStorage.delete(key);&#125;export function clearLocalStorage() &#123; return localStorage.clear();&#125; 123456789101112131415/** * mixin.js 复用的方法放在 mixin 里，尽量让单个组件的代码精简 * */import &#123; mapGetters, mapActions &#125; from "vuex";export const ebookMixin = &#123; computed: &#123; ...mapGetters(["book"]) &#125;, methods: &#123; ...mapActions(['setTest']) &#125;,&#125;; 123456789101112131415161718&lt;!-- 使用 --&gt;&lt;script&gt;import &#123; FONT_SIZE_LIST &#125; from '@/utils/book'import &#123; ebookMixin &#125; from '@/utils/mixin'import &#123; setLocalStorage &#125; from '@/utils/localStorage' // localStorage引入第三方库export default &#123; name: 'app', mixins: [ebookMixin], // mixin以当前代码进行混合，减少重复代码 data() &#123; return &#123; aFontSize: FONT_SIZE_LIST &#125; &#125;, created() &#123; setLocalStorage('test', &#123; name: 1 &#125;) &#125;&#125;&lt;/script&gt; mocknpm install mockjs -D 12345678 // book.js 存放数据文件 module.exports = &#123; list:[ &#123;"name":"肖申克的救赎"&#125;, &#123;"name":"狼性"&#125;, &#123;"name":"弟子规"&#125; ]&#125; 123456 // index.js import Mock from 'mockjs'import book from './book'Mock.mock(/\/book\/ebook/,'get',book) 123456789// main.jsimport './mock' new Vue(&#123; router, i18n, store, render: h =&gt; h(App)&#125;).$mount("#app"); langnpm install vue-i18n -S 1234567891011// cn.js 存放数据文件const messages = &#123; home:&#123; title:'书城' &#125;, book:&#123; title:'书名' &#125;&#125;export default messages 123456789101112131415161718192021 // index.js import Vue from 'vue'import VueI18N from 'vue-i18n'import cn from './cn'Vue.use(VueI18N)const messages = &#123; cn&#125;const locale = 'cn'const i18n = new VueI18N(&#123; locale, messages&#125;) export default i18n 1234567891011// main.jsimport i18n from './lang' // 国际化 Vue.config.productionTip = false;new Vue(&#123; router, i18n, store, render: h =&gt; h(App)&#125;).$mount("#app"); 12&lt;!-- 使用 --&gt;&lt;router-link to="/"&gt;&#123;&#123;$t('home.title')&#125;&#125;&lt;/router-link&gt;|]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具函数]]></title>
    <url>%2FRoyMueZz.github.io%2F%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[字符串转数组对象 123456789101112131415161718192021222324252627282930// 字符串数据结构var str = '&#123;"fileId":20945,"folderId":1,"uploadId":1401,"name":"2019-7-10 10-25-49.JPG","urlName":"6a957d583561508.JPG"&#125;,&#123;"fileId":20952,"folderId":1,"uploadId":1409,"name":"Koala.jpg","urlName":"4b6981873d21c8e.jpg"&#125;,&#123;"fileId":20951,"folderId":1,"uploadId":1408,"name":"Koala.jpg","urlName":"e7a9380346ce52a.jpg"&#125;'function setAttachmentValue(data) &#123; if (data) &#123; var _dataStr = data .substring(0, data.length) .replace(/&#125;,&#123;/g, '&#125;,,&#123;') .replace(/\[/g, '') .replace(/\]/g, '') if (_dataStr.indexOf(',,') &gt; -1) &#123; data = _dataStr.split(',,') &#125; else &#123; var _array = new Array() var _objStr = _dataStr.replace(/\[/g, '').replace(/\]/g, '') _array.push(_objStr) data = _array &#125; for (var u = 0; u &lt; data.length; u++) &#123; if (data[u] &amp;&amp; data[u].length &gt; 0) &#123; var attachmentObj = JSON.parse(data[u].substring(0, data[u].length)) data[u] = attachmentObj &#125; &#125; return data &#125; else &#123; return [] &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
